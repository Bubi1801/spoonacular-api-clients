--[[
  spoonacular API

  The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

  The version of the OpenAPI document: 1.1
  Contact: mail@spoonacular.com
  Generated by: https://openapi-generator.tech
]]

--package spoonacular

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local spoonacular_analyze_a_recipe_search_query_200_response = require "spoonacular.model.analyze_a_recipe_search_query_200_response"
local spoonacular_analyze_recipe_instructions_200_response = require "spoonacular.model.analyze_recipe_instructions_200_response"
local spoonacular_autocomplete_recipe_search_200_response_inner = require "spoonacular.model.autocomplete_recipe_search_200_response_inner"
local spoonacular_classify_cuisine_200_response = require "spoonacular.model.classify_cuisine_200_response"
local spoonacular_compute_glycemic_load_200_response = require "spoonacular.model.compute_glycemic_load_200_response"
local spoonacular_compute_glycemic_load_request = require "spoonacular.model.compute_glycemic_load_request"
local spoonacular_convert_amounts_200_response = require "spoonacular.model.convert_amounts_200_response"
local spoonacular_create_recipe_card_200_response = require "spoonacular.model.create_recipe_card_200_response"
local spoonacular_get_analyzed_recipe_instructions_200_response = require "spoonacular.model.get_analyzed_recipe_instructions_200_response"
local spoonacular_get_random_recipes_200_response = require "spoonacular.model.get_random_recipes_200_response"
local spoonacular_get_recipe_equipment_by_id_200_response = require "spoonacular.model.get_recipe_equipment_by_id_200_response"
local spoonacular_get_recipe_information_bulk_200_response_inner = require "spoonacular.model.get_recipe_information_bulk_200_response_inner"
local spoonacular_get_recipe_information_200_response = require "spoonacular.model.get_recipe_information_200_response"
local spoonacular_get_recipe_ingredients_by_id_200_response = require "spoonacular.model.get_recipe_ingredients_by_id_200_response"
local spoonacular_get_recipe_nutrition_widget_by_id_200_response = require "spoonacular.model.get_recipe_nutrition_widget_by_id_200_response"
local spoonacular_get_recipe_price_breakdown_by_id_200_response = require "spoonacular.model.get_recipe_price_breakdown_by_id_200_response"
local spoonacular_get_recipe_taste_by_id_200_response = require "spoonacular.model.get_recipe_taste_by_id_200_response"
local spoonacular_get_similar_recipes_200_response_inner = require "spoonacular.model.get_similar_recipes_200_response_inner"
local spoonacular_guess_nutrition_by_dish_name_200_response = require "spoonacular.model.guess_nutrition_by_dish_name_200_response"
local spoonacular_parse_ingredients_200_response_inner = require "spoonacular.model.parse_ingredients_200_response_inner"
local spoonacular_quick_answer_200_response = require "spoonacular.model.quick_answer_200_response"
local spoonacular_search_recipes_by_ingredients_200_response_inner = require "spoonacular.model.search_recipes_by_ingredients_200_response_inner"
local spoonacular_search_recipes_by_nutrients_200_response_inner = require "spoonacular.model.search_recipes_by_nutrients_200_response_inner"
local spoonacular_search_recipes_200_response = require "spoonacular.model.search_recipes_200_response"
local spoonacular_set = require "spoonacular.model.set"
local spoonacular_summarize_recipe_200_response = require "spoonacular.model.summarize_recipe_200_response"

local recipes_api = {}
local recipes_api_mt = {
	__name = "recipes_api";
	__index = recipes_api;
}

local function new_recipes_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "https://api.spoonacular.com";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, recipes_api_mt)
end

function recipes_api:analyze_a_recipe_search_query(q)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/queries/analyze?q=%s",
			self.basePath, http_util.encodeURIComponent(q));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_analyze_a_recipe_search_query_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:analyze_recipe_instructions(instructions)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/analyzeInstructions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(http_util.dict_to_query({
		["instructions"] = instructions;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_analyze_recipe_instructions_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:autocomplete_recipe_search(query, Number_)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/autocomplete?query=%s&number=%s",
			self.basePath, http_util.encodeURIComponent(query), http_util.encodeURIComponent(Number_));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_autocomplete_recipe_search_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:classify_cuisine(title, ingredient_list, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/cuisine?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(http_util.dict_to_query({
		["title"] = title;
		["ingredientList"] = ingredient_list;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_classify_cuisine_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:compute_glycemic_load(compute_glycemic_load_request, language)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/food/ingredients/glycemicLoad?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(compute_glycemic_load_request))

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_compute_glycemic_load_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:convert_amounts(ingredient_name, source_amount, source_unit, target_unit)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/convert?ingredientName=%s&sourceAmount=%s&sourceUnit=%s&targetUnit=%s",
			self.basePath, http_util.encodeURIComponent(ingredient_name), http_util.encodeURIComponent(source_amount), http_util.encodeURIComponent(source_unit), http_util.encodeURIComponent(target_unit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_convert_amounts_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:create_recipe_card(title, ingredients, instructions, ready_in_minutes, servings, mask, background_image, image, image_url, author, background_color, font_color, source)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeRecipe",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "multipart/form-data" }
	req.headers:upsert("accept", "multipart/form-data")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(http_util.dict_to_query({
		["title"] = title;
		["ingredients"] = ingredients;
		["instructions"] = instructions;
		["readyInMinutes"] = ready_in_minutes;
		["servings"] = servings;
		["mask"] = mask;
		["backgroundImage"] = background_image;
		["image"] = image;
		["imageUrl"] = image_url;
		["author"] = author;
		["backgroundColor"] = background_color;
		["fontColor"] = font_color;
		["source"] = source;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_create_recipe_card_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:equipment_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:extract_recipe_from_website(url, force_extraction, analyze, include_nutrition, include_taste)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/extract?url=%s&forceExtraction=%s&analyze=%s&includeNutrition=%s&includeTaste=%s",
			self.basePath, http_util.encodeURIComponent(url), http_util.encodeURIComponent(force_extraction), http_util.encodeURIComponent(analyze), http_util.encodeURIComponent(include_nutrition), http_util.encodeURIComponent(include_taste));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_information_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_analyzed_recipe_instructions(id, step_breakdown)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/analyzedInstructions?stepBreakdown=%s",
			self.basePath, id, http_util.encodeURIComponent(step_breakdown));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_analyzed_recipe_instructions_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_random_recipes(limit_license, include_nutrition, include_tags, exclude_tags, Number_)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/random?limitLicense=%s&includeNutrition=%s&include-tags=%s&exclude-tags=%s&number=%s",
			self.basePath, http_util.encodeURIComponent(limit_license), http_util.encodeURIComponent(include_nutrition), http_util.encodeURIComponent(include_tags), http_util.encodeURIComponent(exclude_tags), http_util.encodeURIComponent(Number_));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_random_recipes_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_equipment_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_equipment_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_information(id, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/information?includeNutrition=%s",
			self.basePath, id, http_util.encodeURIComponent(include_nutrition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_information_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_information_bulk(ids, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/informationBulk?ids=%s&includeNutrition=%s",
			self.basePath, http_util.encodeURIComponent(ids), http_util.encodeURIComponent(include_nutrition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_get_recipe_information_bulk_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_ingredients_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_ingredients_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_nutrition_widget_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_nutrition_widget_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_price_breakdown_by_id(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget.json",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_price_breakdown_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_recipe_taste_by_id(id, normalize)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget.json?normalize=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_get_recipe_taste_by_id_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:get_similar_recipes(id, Number_, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/similar?number=%s&limitLicense=%s",
			self.basePath, id, http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_get_similar_recipes_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:guess_nutrition_by_dish_name(title)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/guessNutrition?title=%s",
			self.basePath, http_util.encodeURIComponent(title));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_guess_nutrition_by_dish_name_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:parse_ingredients(ingredient_list, servings, language, include_nutrition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/parseIngredients?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(http_util.dict_to_query({
		["ingredientList"] = ingredient_list;
		["servings"] = servings;
		["includeNutrition"] = include_nutrition;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_parse_ingredients_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:price_breakdown_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:quick_answer(q)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/quickAnswer?q=%s",
			self.basePath, http_util.encodeURIComponent(q));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_quick_answer_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_by_id_image(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget.png",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_label_image(id, show_optional_nutrients, show_zero_values, show_ingredients)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionLabel.png?showOptionalNutrients=%s&showZeroValues=%s&showIngredients=%s",
			self.basePath, id, http_util.encodeURIComponent(show_optional_nutrients), http_util.encodeURIComponent(show_zero_values), http_util.encodeURIComponent(show_ingredients));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_nutrition_label_widget(id, default_css, show_optional_nutrients, show_zero_values, show_ingredients)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionLabel?defaultCss=%s&showOptionalNutrients=%s&showZeroValues=%s&showIngredients=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css), http_util.encodeURIComponent(show_optional_nutrients), http_util.encodeURIComponent(show_zero_values), http_util.encodeURIComponent(show_ingredients));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:recipe_taste_by_id_image(id, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget.png?normalize=%s&rgb=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "image/png" }
	req.headers:upsert("content-type", "image/png")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes(query, cuisine, exclude_cuisine, diet, intolerances, equipment, include_ingredients, exclude_ingredients, type, instructions_required, fill_ingredients, add_recipe_information, add_recipe_nutrition, author, tags, recipe_box_id, title_match, max_ready_time, min_servings, max_servings, ignore_pantry, sort, sort_direction, min_carbs, max_carbs, min_protein, max_protein, min_calories, max_calories, min_fat, max_fat, min_alcohol, max_alcohol, min_caffeine, max_caffeine, min_copper, max_copper, min_calcium, max_calcium, min_choline, max_choline, min_cholesterol, max_cholesterol, min_fluoride, max_fluoride, min_saturated_fat, max_saturated_fat, min_vitamin_a, max_vitamin_a, min_vitamin_c, max_vitamin_c, min_vitamin_d, max_vitamin_d, min_vitamin_e, max_vitamin_e, min_vitamin_k, max_vitamin_k, min_vitamin_b1, max_vitamin_b1, min_vitamin_b2, max_vitamin_b2, min_vitamin_b5, max_vitamin_b5, min_vitamin_b3, max_vitamin_b3, min_vitamin_b6, max_vitamin_b6, min_vitamin_b12, max_vitamin_b12, min_fiber, max_fiber, min_folate, max_folate, min_folic_acid, max_folic_acid, min_iodine, max_iodine, min_iron, max_iron, min_magnesium, max_magnesium, min_manganese, max_manganese, min_phosphorus, max_phosphorus, min_potassium, max_potassium, min_selenium, max_selenium, min_sodium, max_sodium, min_sugar, max_sugar, min_zinc, max_zinc, offset, Number_, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/complexSearch?query=%s&cuisine=%s&excludeCuisine=%s&diet=%s&intolerances=%s&equipment=%s&includeIngredients=%s&excludeIngredients=%s&type=%s&instructionsRequired=%s&fillIngredients=%s&addRecipeInformation=%s&addRecipeNutrition=%s&author=%s&tags=%s&recipeBoxId=%s&titleMatch=%s&maxReadyTime=%s&minServings=%s&maxServings=%s&ignorePantry=%s&sort=%s&sortDirection=%s&minCarbs=%s&maxCarbs=%s&minProtein=%s&maxProtein=%s&minCalories=%s&maxCalories=%s&minFat=%s&maxFat=%s&minAlcohol=%s&maxAlcohol=%s&minCaffeine=%s&maxCaffeine=%s&minCopper=%s&maxCopper=%s&minCalcium=%s&maxCalcium=%s&minCholine=%s&maxCholine=%s&minCholesterol=%s&maxCholesterol=%s&minFluoride=%s&maxFluoride=%s&minSaturatedFat=%s&maxSaturatedFat=%s&minVitaminA=%s&maxVitaminA=%s&minVitaminC=%s&maxVitaminC=%s&minVitaminD=%s&maxVitaminD=%s&minVitaminE=%s&maxVitaminE=%s&minVitaminK=%s&maxVitaminK=%s&minVitaminB1=%s&maxVitaminB1=%s&minVitaminB2=%s&maxVitaminB2=%s&minVitaminB5=%s&maxVitaminB5=%s&minVitaminB3=%s&maxVitaminB3=%s&minVitaminB6=%s&maxVitaminB6=%s&minVitaminB12=%s&maxVitaminB12=%s&minFiber=%s&maxFiber=%s&minFolate=%s&maxFolate=%s&minFolicAcid=%s&maxFolicAcid=%s&minIodine=%s&maxIodine=%s&minIron=%s&maxIron=%s&minMagnesium=%s&maxMagnesium=%s&minManganese=%s&maxManganese=%s&minPhosphorus=%s&maxPhosphorus=%s&minPotassium=%s&maxPotassium=%s&minSelenium=%s&maxSelenium=%s&minSodium=%s&maxSodium=%s&minSugar=%s&maxSugar=%s&minZinc=%s&maxZinc=%s&offset=%s&number=%s&limitLicense=%s",
			self.basePath, http_util.encodeURIComponent(query), http_util.encodeURIComponent(cuisine), http_util.encodeURIComponent(exclude_cuisine), http_util.encodeURIComponent(diet), http_util.encodeURIComponent(intolerances), http_util.encodeURIComponent(equipment), http_util.encodeURIComponent(include_ingredients), http_util.encodeURIComponent(exclude_ingredients), http_util.encodeURIComponent(type), http_util.encodeURIComponent(instructions_required), http_util.encodeURIComponent(fill_ingredients), http_util.encodeURIComponent(add_recipe_information), http_util.encodeURIComponent(add_recipe_nutrition), http_util.encodeURIComponent(author), http_util.encodeURIComponent(tags), http_util.encodeURIComponent(recipe_box_id), http_util.encodeURIComponent(title_match), http_util.encodeURIComponent(max_ready_time), http_util.encodeURIComponent(min_servings), http_util.encodeURIComponent(max_servings), http_util.encodeURIComponent(ignore_pantry), http_util.encodeURIComponent(sort), http_util.encodeURIComponent(sort_direction), http_util.encodeURIComponent(min_carbs), http_util.encodeURIComponent(max_carbs), http_util.encodeURIComponent(min_protein), http_util.encodeURIComponent(max_protein), http_util.encodeURIComponent(min_calories), http_util.encodeURIComponent(max_calories), http_util.encodeURIComponent(min_fat), http_util.encodeURIComponent(max_fat), http_util.encodeURIComponent(min_alcohol), http_util.encodeURIComponent(max_alcohol), http_util.encodeURIComponent(min_caffeine), http_util.encodeURIComponent(max_caffeine), http_util.encodeURIComponent(min_copper), http_util.encodeURIComponent(max_copper), http_util.encodeURIComponent(min_calcium), http_util.encodeURIComponent(max_calcium), http_util.encodeURIComponent(min_choline), http_util.encodeURIComponent(max_choline), http_util.encodeURIComponent(min_cholesterol), http_util.encodeURIComponent(max_cholesterol), http_util.encodeURIComponent(min_fluoride), http_util.encodeURIComponent(max_fluoride), http_util.encodeURIComponent(min_saturated_fat), http_util.encodeURIComponent(max_saturated_fat), http_util.encodeURIComponent(min_vitamin_a), http_util.encodeURIComponent(max_vitamin_a), http_util.encodeURIComponent(min_vitamin_c), http_util.encodeURIComponent(max_vitamin_c), http_util.encodeURIComponent(min_vitamin_d), http_util.encodeURIComponent(max_vitamin_d), http_util.encodeURIComponent(min_vitamin_e), http_util.encodeURIComponent(max_vitamin_e), http_util.encodeURIComponent(min_vitamin_k), http_util.encodeURIComponent(max_vitamin_k), http_util.encodeURIComponent(min_vitamin_b1), http_util.encodeURIComponent(max_vitamin_b1), http_util.encodeURIComponent(min_vitamin_b2), http_util.encodeURIComponent(max_vitamin_b2), http_util.encodeURIComponent(min_vitamin_b5), http_util.encodeURIComponent(max_vitamin_b5), http_util.encodeURIComponent(min_vitamin_b3), http_util.encodeURIComponent(max_vitamin_b3), http_util.encodeURIComponent(min_vitamin_b6), http_util.encodeURIComponent(max_vitamin_b6), http_util.encodeURIComponent(min_vitamin_b12), http_util.encodeURIComponent(max_vitamin_b12), http_util.encodeURIComponent(min_fiber), http_util.encodeURIComponent(max_fiber), http_util.encodeURIComponent(min_folate), http_util.encodeURIComponent(max_folate), http_util.encodeURIComponent(min_folic_acid), http_util.encodeURIComponent(max_folic_acid), http_util.encodeURIComponent(min_iodine), http_util.encodeURIComponent(max_iodine), http_util.encodeURIComponent(min_iron), http_util.encodeURIComponent(max_iron), http_util.encodeURIComponent(min_magnesium), http_util.encodeURIComponent(max_magnesium), http_util.encodeURIComponent(min_manganese), http_util.encodeURIComponent(max_manganese), http_util.encodeURIComponent(min_phosphorus), http_util.encodeURIComponent(max_phosphorus), http_util.encodeURIComponent(min_potassium), http_util.encodeURIComponent(max_potassium), http_util.encodeURIComponent(min_selenium), http_util.encodeURIComponent(max_selenium), http_util.encodeURIComponent(min_sodium), http_util.encodeURIComponent(max_sodium), http_util.encodeURIComponent(min_sugar), http_util.encodeURIComponent(max_sugar), http_util.encodeURIComponent(min_zinc), http_util.encodeURIComponent(max_zinc), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_search_recipes_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes_by_ingredients(ingredients, Number_, limit_license, ranking, ignore_pantry)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/findByIngredients?ingredients=%s&number=%s&limitLicense=%s&ranking=%s&ignorePantry=%s",
			self.basePath, http_util.encodeURIComponent(ingredients), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(limit_license), http_util.encodeURIComponent(ranking), http_util.encodeURIComponent(ignore_pantry));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_search_recipes_by_ingredients_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:search_recipes_by_nutrients(min_carbs, max_carbs, min_protein, max_protein, min_calories, max_calories, min_fat, max_fat, min_alcohol, max_alcohol, min_caffeine, max_caffeine, min_copper, max_copper, min_calcium, max_calcium, min_choline, max_choline, min_cholesterol, max_cholesterol, min_fluoride, max_fluoride, min_saturated_fat, max_saturated_fat, min_vitamin_a, max_vitamin_a, min_vitamin_c, max_vitamin_c, min_vitamin_d, max_vitamin_d, min_vitamin_e, max_vitamin_e, min_vitamin_k, max_vitamin_k, min_vitamin_b1, max_vitamin_b1, min_vitamin_b2, max_vitamin_b2, min_vitamin_b5, max_vitamin_b5, min_vitamin_b3, max_vitamin_b3, min_vitamin_b6, max_vitamin_b6, min_vitamin_b12, max_vitamin_b12, min_fiber, max_fiber, min_folate, max_folate, min_folic_acid, max_folic_acid, min_iodine, max_iodine, min_iron, max_iron, min_magnesium, max_magnesium, min_manganese, max_manganese, min_phosphorus, max_phosphorus, min_potassium, max_potassium, min_selenium, max_selenium, min_sodium, max_sodium, min_sugar, max_sugar, min_zinc, max_zinc, offset, Number_, random, limit_license)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/findByNutrients?minCarbs=%s&maxCarbs=%s&minProtein=%s&maxProtein=%s&minCalories=%s&maxCalories=%s&minFat=%s&maxFat=%s&minAlcohol=%s&maxAlcohol=%s&minCaffeine=%s&maxCaffeine=%s&minCopper=%s&maxCopper=%s&minCalcium=%s&maxCalcium=%s&minCholine=%s&maxCholine=%s&minCholesterol=%s&maxCholesterol=%s&minFluoride=%s&maxFluoride=%s&minSaturatedFat=%s&maxSaturatedFat=%s&minVitaminA=%s&maxVitaminA=%s&minVitaminC=%s&maxVitaminC=%s&minVitaminD=%s&maxVitaminD=%s&minVitaminE=%s&maxVitaminE=%s&minVitaminK=%s&maxVitaminK=%s&minVitaminB1=%s&maxVitaminB1=%s&minVitaminB2=%s&maxVitaminB2=%s&minVitaminB5=%s&maxVitaminB5=%s&minVitaminB3=%s&maxVitaminB3=%s&minVitaminB6=%s&maxVitaminB6=%s&minVitaminB12=%s&maxVitaminB12=%s&minFiber=%s&maxFiber=%s&minFolate=%s&maxFolate=%s&minFolicAcid=%s&maxFolicAcid=%s&minIodine=%s&maxIodine=%s&minIron=%s&maxIron=%s&minMagnesium=%s&maxMagnesium=%s&minManganese=%s&maxManganese=%s&minPhosphorus=%s&maxPhosphorus=%s&minPotassium=%s&maxPotassium=%s&minSelenium=%s&maxSelenium=%s&minSodium=%s&maxSodium=%s&minSugar=%s&maxSugar=%s&minZinc=%s&maxZinc=%s&offset=%s&number=%s&random=%s&limitLicense=%s",
			self.basePath, http_util.encodeURIComponent(min_carbs), http_util.encodeURIComponent(max_carbs), http_util.encodeURIComponent(min_protein), http_util.encodeURIComponent(max_protein), http_util.encodeURIComponent(min_calories), http_util.encodeURIComponent(max_calories), http_util.encodeURIComponent(min_fat), http_util.encodeURIComponent(max_fat), http_util.encodeURIComponent(min_alcohol), http_util.encodeURIComponent(max_alcohol), http_util.encodeURIComponent(min_caffeine), http_util.encodeURIComponent(max_caffeine), http_util.encodeURIComponent(min_copper), http_util.encodeURIComponent(max_copper), http_util.encodeURIComponent(min_calcium), http_util.encodeURIComponent(max_calcium), http_util.encodeURIComponent(min_choline), http_util.encodeURIComponent(max_choline), http_util.encodeURIComponent(min_cholesterol), http_util.encodeURIComponent(max_cholesterol), http_util.encodeURIComponent(min_fluoride), http_util.encodeURIComponent(max_fluoride), http_util.encodeURIComponent(min_saturated_fat), http_util.encodeURIComponent(max_saturated_fat), http_util.encodeURIComponent(min_vitamin_a), http_util.encodeURIComponent(max_vitamin_a), http_util.encodeURIComponent(min_vitamin_c), http_util.encodeURIComponent(max_vitamin_c), http_util.encodeURIComponent(min_vitamin_d), http_util.encodeURIComponent(max_vitamin_d), http_util.encodeURIComponent(min_vitamin_e), http_util.encodeURIComponent(max_vitamin_e), http_util.encodeURIComponent(min_vitamin_k), http_util.encodeURIComponent(max_vitamin_k), http_util.encodeURIComponent(min_vitamin_b1), http_util.encodeURIComponent(max_vitamin_b1), http_util.encodeURIComponent(min_vitamin_b2), http_util.encodeURIComponent(max_vitamin_b2), http_util.encodeURIComponent(min_vitamin_b5), http_util.encodeURIComponent(max_vitamin_b5), http_util.encodeURIComponent(min_vitamin_b3), http_util.encodeURIComponent(max_vitamin_b3), http_util.encodeURIComponent(min_vitamin_b6), http_util.encodeURIComponent(max_vitamin_b6), http_util.encodeURIComponent(min_vitamin_b12), http_util.encodeURIComponent(max_vitamin_b12), http_util.encodeURIComponent(min_fiber), http_util.encodeURIComponent(max_fiber), http_util.encodeURIComponent(min_folate), http_util.encodeURIComponent(max_folate), http_util.encodeURIComponent(min_folic_acid), http_util.encodeURIComponent(max_folic_acid), http_util.encodeURIComponent(min_iodine), http_util.encodeURIComponent(max_iodine), http_util.encodeURIComponent(min_iron), http_util.encodeURIComponent(max_iron), http_util.encodeURIComponent(min_magnesium), http_util.encodeURIComponent(max_magnesium), http_util.encodeURIComponent(min_manganese), http_util.encodeURIComponent(max_manganese), http_util.encodeURIComponent(min_phosphorus), http_util.encodeURIComponent(max_phosphorus), http_util.encodeURIComponent(min_potassium), http_util.encodeURIComponent(max_potassium), http_util.encodeURIComponent(min_selenium), http_util.encodeURIComponent(max_selenium), http_util.encodeURIComponent(min_sodium), http_util.encodeURIComponent(max_sodium), http_util.encodeURIComponent(min_sugar), http_util.encodeURIComponent(max_sugar), http_util.encodeURIComponent(min_zinc), http_util.encodeURIComponent(max_zinc), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(Number_), http_util.encodeURIComponent(random), http_util.encodeURIComponent(limit_license));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		for _, ob in ipairs(result) do
			spoonacular_search_recipes_by_nutrients_200_response_inner.cast(ob)
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:summarize_recipe(id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/summary",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return spoonacular_summarize_recipe_200_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_equipment(instructions, view, default_css, show_backlink)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeEquipment",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	req:set_body(http_util.dict_to_query({
		["instructions"] = instructions;
		["view"] = view;
		["defaultCss"] = default_css;
		["showBacklink"] = show_backlink;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_price_breakdown(ingredient_list, servings, language, mode, default_css, show_backlink)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizePriceEstimator?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	req:set_body(http_util.dict_to_query({
		["ingredientList"] = ingredient_list;
		["servings"] = servings;
		["mode"] = mode;
		["defaultCss"] = default_css;
		["showBacklink"] = show_backlink;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_equipment_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/equipmentWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_ingredients_by_id(id, default_css, measure)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/ingredientWidget?defaultCss=%s&measure=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css), http_util.encodeURIComponent(measure));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_nutrition(ingredient_list, servings, language, default_css, show_backlink)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeNutrition?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	req:set_body(http_util.dict_to_query({
		["ingredientList"] = ingredient_list;
		["servings"] = servings;
		["defaultCss"] = default_css;
		["showBacklink"] = show_backlink;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_nutrition_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/nutritionWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_price_breakdown_by_id(id, default_css)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/priceBreakdownWidget?defaultCss=%s",
			self.basePath, id, http_util.encodeURIComponent(default_css));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_taste(ingredient_list, language, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/visualizeTaste?language=%s",
			self.basePath, http_util.encodeURIComponent(language));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/x-www-form-urlencoded" }
	req.headers:upsert("accept", "application/x-www-form-urlencoded")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	req:set_body(http_util.dict_to_query({
		["ingredientList"] = ingredient_list;
		["normalize"] = normalize;
		["rgb"] = rgb;
	}))
	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function recipes_api:visualize_recipe_taste_by_id(id, normalize, rgb)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/recipes/%s/tasteWidget?normalize=%s&rgb=%s",
			self.basePath, id, http_util.encodeURIComponent(normalize), http_util.encodeURIComponent(rgb));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "text/html" }
	req.headers:upsert("content-type", "text/html")

	-- api key in headers 'x-api-key'
	if self.api_key['x-api-key'] then
		req.headers:upsert("apiKeyScheme", self.api_key['x-api-key'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return result, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_recipes_api;
}
